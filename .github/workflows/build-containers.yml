name: Trigger ML Container Build

on:
  workflow_dispatch:  # Manual trigger
    inputs:
      container:
        description: "Limit build to a single container (sfm|3dgs|compressor)"
        required: false
        default: ""
      base_only:
        description: "Build only the base image for the specified container"
        required: false
        default: "false"
      compute_type:
        description: "Optional CodeBuild compute type override (e.g., BUILD_GENERAL1_LARGE, BUILD_GENERAL1_XLARGE, BUILD_GENERAL1_2XLARGE)"
        required: false
        default: ""
  push:
    # Trigger on any branch when container files change
    paths:
      - 'infrastructure/containers/**'
      - 'scripts/deployment/deploy.sh'
      - 'buildspec.yml'

jobs:
  trigger-codebuild:
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name == 'main' && 'production' || 'staging' }}
    permissions:
      id-token: write   # for GitHub OIDC
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Needed for branch diffing

    - name: Detect branch context and changed containers
      id: branch
      run: |
        set -euo pipefail

        BRANCH_NAME="${GITHUB_REF_NAME}"
        echo "Working branch: $BRANCH_NAME"

        SANITIZED_SUFFIX=$(python scripts/get_branch_suffix.py "$BRANCH_NAME")
        echo "Sanitized suffix: $SANITIZED_SUFFIX"
        echo "branch_suffix=$SANITIZED_SUFFIX" >> $GITHUB_OUTPUT

        ECR_SUFFIX=$(python scripts/get_branch_suffix.py "$BRANCH_NAME" --mode ecr)
        echo "ECR suffix: ${ECR_SUFFIX:-<shared>}"
        echo "ecr_suffix=$ECR_SUFFIX" >> $GITHUB_OUTPUT

        if git rev-parse HEAD~1 >/dev/null 2>&1; then
          DIFF_BASE="HEAD~1"
        else
          git fetch origin development --depth=1 || true
          DIFF_BASE=$(git merge-base HEAD origin/development || echo "")
        fi

        if [ -n "$DIFF_BASE" ]; then
          CHANGED_FILES=$(git diff --name-only "$DIFF_BASE"...HEAD || git diff --name-only "$DIFF_BASE" HEAD)
        else
          CHANGED_FILES=$(git diff --name-only HEAD || true)
        fi

        echo "Changed files:"
        echo "$CHANGED_FILES"

        CONTAINERS_TO_BUILD=""

        # Only detect containers that have actual file changes
        for container in sfm 3dgs compressor; do
          if echo "$CHANGED_FILES" | grep -q "infrastructure/containers/${container}/"; then
            CONTAINERS_TO_BUILD="$CONTAINERS_TO_BUILD $container"
            echo "Detected change in ${container} container"
          fi
        done

        # Note: deploy.sh and buildspec.yml changes don't require container rebuilds
        # They only affect the build process, not the container contents

        CONTAINERS_TO_BUILD=$(echo "$CONTAINERS_TO_BUILD" | xargs 2>/dev/null || true)
        echo "changed_containers=${CONTAINERS_TO_BUILD:-}" >> $GITHUB_OUTPUT

    - name: Configure AWS credentials (production via OIDC)
      if: github.ref_name == 'main'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
        aws-region: us-west-2

    - name: Configure AWS credentials (staging via access keys)
      if: github.ref_name != 'main'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Determine container build requirements
      id: build_plan
      run: |
        set -euo pipefail

        BRANCH_SUFFIX="${{ steps.branch.outputs.ecr_suffix }}"
        CHANGED="${{ steps.branch.outputs.changed_containers }}"
        INPUT_CONTAINER="${{ inputs.container }}"
        CONTAINERS_TO_BUILD=""
        CONTAINERS_TO_IMPORT=""
        CONTAINER_LIST="sfm 3dgs compressor"

        if [ -n "$INPUT_CONTAINER" ]; then
          echo "Container override provided: $INPUT_CONTAINER"
          CONTAINERS_TO_BUILD="$INPUT_CONTAINER"
          CONTAINER_LIST="$INPUT_CONTAINER"
        elif [ -n "$CHANGED" ]; then
          echo "Containers changed in git diff: $CHANGED"
          CONTAINER_LIST="$CHANGED"
        fi

        # Check if shared repo has latest tag
        check_repo_has_latest() {
          local container_name="$1"
          local shared_repo="spaceport/${container_name}"
          
          if ! aws ecr describe-repositories --region us-west-2 --repository-names "$shared_repo" >/dev/null 2>&1; then
            return 1
          fi
          
          aws ecr describe-images \
            --region us-west-2 \
            --repository-name "$shared_repo" \
            --image-ids imageTag=latest >/dev/null 2>&1
        }

        # Check shared repos and decide build/import using branch tags
        ensure_repo_ready() {
          local container_name="$1"
          local repo_name="spaceport/${container_name}"

          # If container files changed, always build (don't import)
          if echo "$CHANGED" | grep -q "$container_name"; then
            echo "Container $container_name has file changes - will build"
            CONTAINERS_TO_BUILD="$CONTAINERS_TO_BUILD $container_name"
            return
          fi

          # Repo missing -> build
          if ! aws ecr describe-repositories --region us-west-2 --repository-names "$repo_name" >/dev/null 2>&1; then
            echo "Shared repo $repo_name missing - will build $container_name"
            CONTAINERS_TO_BUILD="$CONTAINERS_TO_BUILD $container_name"
            return
          fi

          # Latest missing -> build
          if ! check_repo_has_latest "$container_name"; then
            echo "Repo $repo_name missing 'latest' tag - will build $container_name"
            CONTAINERS_TO_BUILD="$CONTAINERS_TO_BUILD $container_name"
            return
          fi

          # Base image missing -> build
          if ! aws ecr describe-images --region us-west-2 --repository-name "$repo_name" --image-ids imageTag=base >/dev/null 2>&1; then
            echo "Repo $repo_name missing 'base' tag - will build $container_name"
            CONTAINERS_TO_BUILD="$CONTAINERS_TO_BUILD $container_name"
            return
          fi

          # Branch tag missing -> import (retag latest)
          if [ -n "$BRANCH_SUFFIX" ]; then
            if ! aws ecr describe-images --region us-west-2 --repository-name "$repo_name" --image-ids imageTag="$BRANCH_SUFFIX" >/dev/null 2>&1; then
              echo "Repo $repo_name missing branch tag ${BRANCH_SUFFIX} - will import"
              CONTAINERS_TO_IMPORT="$CONTAINERS_TO_IMPORT $container_name"
            fi
          fi
        }

        # Shared repos only; branch tags handled as retags
        for container in $CONTAINER_LIST; do
          ensure_repo_ready "$container"
        done

        UNIQUE_CONTAINERS_TO_BUILD=$(echo "$CONTAINERS_TO_BUILD" | xargs -n1 2>/dev/null | sort -u | xargs 2>/dev/null || true)
        UNIQUE_CONTAINERS_TO_IMPORT=$(echo "$CONTAINERS_TO_IMPORT" | xargs -n1 2>/dev/null | sort -u | xargs 2>/dev/null || true)

        if [ -z "$UNIQUE_CONTAINERS_TO_BUILD" ] && [ -z "$UNIQUE_CONTAINERS_TO_IMPORT" ]; then
          echo "No container build or import required for this branch"
          echo "containers=none" >> $GITHUB_OUTPUT
          echo "containers_to_build=" >> $GITHUB_OUTPUT
          echo "containers_to_import=" >> $GITHUB_OUTPUT
          echo "build_required=false" >> $GITHUB_OUTPUT
          echo "import_required=false" >> $GITHUB_OUTPUT
        else
        if [ -n "$UNIQUE_CONTAINERS_TO_BUILD" ]; then
          echo "Containers to build: $UNIQUE_CONTAINERS_TO_BUILD"
          echo "containers=$UNIQUE_CONTAINERS_TO_BUILD" >> $GITHUB_OUTPUT
          echo "containers_to_build=$UNIQUE_CONTAINERS_TO_BUILD" >> $GITHUB_OUTPUT
          echo "build_required=true" >> $GITHUB_OUTPUT
          else
            echo "containers=none" >> $GITHUB_OUTPUT
            echo "containers_to_build=" >> $GITHUB_OUTPUT
            echo "build_required=false" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$UNIQUE_CONTAINERS_TO_IMPORT" ]; then
            echo "Containers to import: $UNIQUE_CONTAINERS_TO_IMPORT"
            echo "containers_to_import=$UNIQUE_CONTAINERS_TO_IMPORT" >> $GITHUB_OUTPUT
            echo "import_required=true" >> $GITHUB_OUTPUT
          else
            echo "containers_to_import=" >> $GITHUB_OUTPUT
            echo "import_required=false" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Create ECR repositories if they don't exist
      if: ${{ steps.build_plan.outputs.build_required == 'true' || steps.build_plan.outputs.import_required == 'true' }}
      run: |
        BRANCH_SUFFIX="${{ steps.branch.outputs.ecr_suffix }}"
        CONTAINERS_TO_BUILD="${{ steps.build_plan.outputs.containers_to_build }}"
        CONTAINERS_TO_IMPORT="${{ steps.build_plan.outputs.containers_to_import }}"
        
        apply_lifecycle() {
          local repo="$1"
          local policy='{
            "rules": [
              {
                "rulePriority": 1,
                "description": "Expire untagged after 7d",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "sinceImagePushed",
                  "countUnit": "days",
                  "countNumber": 7
                },
                "action": {"type": "expire"}
              },
              {
                "rulePriority": 2,
                "description": "Expire agent branch tags after 28d",
                "selection": {
                  "tagStatus": "tagged",
                  "tagPrefixList": ["agent-"],
                  "countType": "sinceImagePushed",
                  "countUnit": "days",
                  "countNumber": 28
                },
                "action": {"type": "expire"}
              }
            ]
          }'
          aws ecr put-lifecycle-policy --region us-west-2 --repository-name "$repo" --lifecycle-policy-text "$policy"
        }

        for repo in spaceport/sfm spaceport/3dgs spaceport/compressor; do
          echo "Ensuring shared ECR repository exists: $repo"
          if ! aws ecr describe-repositories --region us-west-2 --repository-names "$repo" >/dev/null 2>&1; then
            aws ecr create-repository --region us-west-2 --repository-name "$repo" --image-scanning-configuration scanOnPush=true
          fi
          apply_lifecycle "$repo"
        done

    - name: Retag latest to branch tag without CodeBuild
      if: ${{ steps.build_plan.outputs.build_required != 'true' && steps.build_plan.outputs.import_required == 'true' }}
      run: |
        set -euo pipefail
        BRANCH_SUFFIX="${{ steps.branch.outputs.ecr_suffix }}"
        if [ -z "$BRANCH_SUFFIX" ]; then
          echo "Branch suffix empty; nothing to retag."
          exit 0
        fi

        retag() {
          local container="$1"
          local repo="spaceport/${container}"
          echo "Retagging ${repo}:latest -> ${BRANCH_SUFFIX}"
          manifest=$(aws ecr batch-get-image --region us-west-2 --repository-name "$repo" --image-ids imageTag=latest --query 'images[0].imageManifest' --output text)
          if [ -z "$manifest" ] || [ "$manifest" = "None" ]; then
            echo "No latest image found for $repo; cannot retag."
            exit 1
          fi
          aws ecr put-image --region us-west-2 --repository-name "$repo" --image-tag "$BRANCH_SUFFIX" --image-manifest "$manifest"
        }

        for c in ${{ steps.build_plan.outputs.containers_to_import }}; do
          retag "$c"
        done

    - name: Ensure CodeBuild role and project exist (prod/staging)
      if: ${{ steps.build_plan.outputs.build_required == 'true' }}
      run: |
        ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
        echo "Using account: $ACCOUNT"

        # Ensure CodeBuild service role
        set +e
        aws iam get-role --role-name CodeBuildServiceRole >/dev/null 2>&1
        MISSING_ROLE=$?
        set -e
        if [ "$MISSING_ROLE" -ne 0 ]; then
          echo "Creating CodeBuildServiceRole..."
          # Write trust.json without heredoc to avoid delimiter parsing issues
          echo '{'            > trust.json
          echo '  "Version": "2012-10-17",' >> trust.json
          echo '  "Statement": ['            >> trust.json
          echo '    {'                         >> trust.json
          echo '      "Effect": "Allow",'   >> trust.json
          echo '      "Principal": {"Service": "codebuild.amazonaws.com"},' >> trust.json
          echo '      "Action": "sts:AssumeRole"' >> trust.json
          echo '    }'                         >> trust.json
          echo '  ]'                           >> trust.json
          echo '}'                             >> trust.json
          aws iam create-role --role-name CodeBuildServiceRole --assume-role-policy-document file://trust.json
          aws iam attach-role-policy --role-name CodeBuildServiceRole --policy-arn arn:aws:iam::aws:policy/AWSCodeBuildAdminAccess
          aws iam attach-role-policy --role-name CodeBuildServiceRole --policy-arn arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryPowerUser
          aws iam attach-role-policy --role-name CodeBuildServiceRole --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess
          aws iam attach-role-policy --role-name CodeBuildServiceRole --policy-arn arn:aws:iam::aws:policy/CloudWatchLogsFullAccess
        else
          echo "CodeBuildServiceRole already exists."
        fi

        ROLE_ARN=$(aws iam get-role --role-name CodeBuildServiceRole --query 'Role.Arn' --output text)
        echo "Service role: $ROLE_ARN"

        # Ensure CodeBuild project
        set +e
        aws codebuild batch-get-projects --names spaceport-ml-containers --query 'projects[0].name' --output text | grep -q spaceport-ml-containers
        MISSING_PROJ=$?
        set -e
        REPO_URL="https://github.com/${{ github.repository }}.git"
        if [ "$MISSING_PROJ" -ne 0 ]; then
          echo "Creating CodeBuild project spaceport-ml-containers..."
          # Create project directly with role ARN instead of REPLACE_ME logic
          aws codebuild create-project \
            --name spaceport-ml-containers \
            --description "Build ML containers for Spaceport SOGS pipeline with PyTorch + CUDA" \
            --source type=GITHUB,location=${REPO_URL},buildspec=buildspec.yml,gitCloneDepth=1,reportBuildStatus=true \
            --artifacts type=NO_ARTIFACTS \
            --environment type=LINUX_CONTAINER,image=aws/codebuild/standard:7.0,computeType=BUILD_GENERAL1_LARGE,privilegedMode=true \
            --service-role "$ROLE_ARN" \
            --timeout-in-minutes 120 \
            --queued-timeout-in-minutes 30 \
            --tags key=Project,value=Spaceport key=Purpose,value=ML-Container-Build
          echo "Created CodeBuild project."
        else
          echo "CodeBuild project already exists. Reusing existing configuration."
        fi

        echo "Ensuring CodeBuild timeout is 120 minutes..."
        aws codebuild update-project \
          --name spaceport-ml-containers \
          --environment type=LINUX_CONTAINER,image=aws/codebuild/standard:7.0,computeType=BUILD_GENERAL1_LARGE,privilegedMode=true \
          --timeout-in-minutes 120 \
          --queued-timeout-in-minutes 30 \
          --service-role "$ROLE_ARN" \
          >/dev/null

    - name: Trigger CodeBuild for container builds/imports
      if: ${{ steps.build_plan.outputs.build_required == 'true' }}
      run: |
        echo "üöÄ Triggering AWS CodeBuild for ML container builds..."
        echo "Building containers: ${{ steps.build_plan.outputs.containers_to_build }}"
        SOURCE_REPO="https://github.com/${{ github.repository }}.git"
        COMPUTE_TYPE_INPUT="${{ inputs.compute_type }}"
        DEFAULT_COMPUTE="BUILD_GENERAL1_LARGE"
        BASE_COMPUTE="BUILD_GENERAL1_2XLARGE"

        if [ -n "$COMPUTE_TYPE_INPUT" ]; then
          echo "Compute override requested: $COMPUTE_TYPE_INPUT"
          COMPUTE_ARGS=(--compute-type-override "$COMPUTE_TYPE_INPUT")
        elif [ "${{ inputs.base_only }}" = "true" ]; then
          echo "Base-only build detected; using $BASE_COMPUTE for extra headroom"
          COMPUTE_ARGS=(--compute-type-override "$BASE_COMPUTE")
        else
          echo "Defaulting to $DEFAULT_COMPUTE for app-layer build (cheaper)"
          COMPUTE_ARGS=(--compute-type-override "$DEFAULT_COMPUTE")
        fi
        
        wait_for_capacity() {
          while true; do
            ACTIVE_IDS=$(aws codebuild list-builds-for-project \
              --project-name spaceport-ml-containers \
              --max-items 5 \
              --sort-order DESCENDING \
              --output json | jq -r '.ids[]?' | xargs 2>/dev/null || true)

            if [ -z "$ACTIVE_IDS" ]; then
              break
            fi

            BUSY_IDS=$(aws codebuild batch-get-builds --ids $ACTIVE_IDS --output json \
              | jq -r '.builds[]? | select(.buildStatus=="IN_PROGRESS" or .buildStatus=="QUEUED") | .id' \
              | xargs 2>/dev/null || true)

            if [ -z "$BUSY_IDS" ]; then
              break
            fi

            echo "Another CodeBuild job is still running ($BUSY_IDS). Waiting 30s for capacity..."
            sleep 30
          done
        }

        wait_for_capacity
        
        BUILD_ID=$(aws codebuild start-build \
          --project-name spaceport-ml-containers \
          --source-version ${{ github.sha }} \
          --source-type-override GITHUB \
          --source-location-override "${SOURCE_REPO}" \
          --timeout-in-minutes-override 120 \
          "${COMPUTE_ARGS[@]}" \
          --environment-variables-override \
            name=CONTAINERS_TO_BUILD,value="${{ steps.build_plan.outputs.containers_to_build }}" \
            name=CONTAINERS_TO_IMPORT,value="${{ steps.build_plan.outputs.containers_to_import }}" \
            name=BRANCH_SUFFIX,value="${{ steps.branch.outputs.ecr_suffix }}" \
            name=BUILD_BASE_ONLY,value="${{ inputs.base_only == 'true' && '1' || '0' }}" \
          --query 'build.id' \
          --output text)
        
        echo "‚úÖ CodeBuild triggered successfully!"
        echo "Build ID: $BUILD_ID"
        echo "Monitor progress: https://console.aws.amazon.com/codesuite/codebuild/projects/spaceport-ml-containers/build/$BUILD_ID"
        
        # Wait for build to complete (optional - can be removed for async)
        echo "‚è≥ Waiting for CodeBuild to complete..."
        aws codebuild batch-get-builds --ids $BUILD_ID --query 'builds[0].buildStatus' --output text
        
        # Poll for completion
        while true; do
          STATUS=$(aws codebuild batch-get-builds --ids $BUILD_ID --query 'builds[0].buildStatus' --output text)
          echo "Build status: $STATUS"
          
          if [ "$STATUS" = "SUCCEEDED" ]; then
            echo "‚úÖ CodeBuild completed successfully!"
            break
          elif [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "FAULT" ] || [ "$STATUS" = "STOPPED" ] || [ "$STATUS" = "TIMED_OUT" ]; then
            echo "‚ùå CodeBuild failed with status: $STATUS"
            exit 1
          fi
          
          sleep 30
        done

    - name: Output container URIs
      if: ${{ steps.build_plan.outputs.build_required == 'true' || steps.build_plan.outputs.import_required == 'true' }}
      run: |
        if [ "${{ steps.build_plan.outputs.build_required }}" = "true" ]; then
          echo "‚úÖ ML Containers built and pushed via CodeBuild:"
          echo "Built containers: ${{ steps.build_plan.outputs.containers_to_build }}"
        fi
        if [ "${{ steps.build_plan.outputs.import_required }}" = "true" ]; then
          echo "‚úÖ ML Containers imported from shared repos:"
          echo "Imported containers: ${{ steps.build_plan.outputs.containers_to_import }}"
        fi
        echo "Account: $(aws sts get-caller-identity --query Account --output text)"
        echo "Region: us-west-2"

    - name: Skip notice when no containers require builds or imports
      if: ${{ steps.build_plan.outputs.build_required != 'true' && steps.build_plan.outputs.import_required != 'true' }}
      run: |
        echo "‚ÑπÔ∏è Container build/import skipped (branch already has usable images)."

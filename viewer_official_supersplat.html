<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spaceport 3D Model Viewer - Official PlayCanvas SuperSplat</title>
    <meta name="description" content="View 3D Gaussian Splat models using official PlayCanvas SuperSplat technology">
    
    <!-- PlayCanvas Engine -->
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    
    <style>
        :root {
            --primary-color: #ffffff;
            --background-dark: #000000;
            --accent-blue: #3b82f6;
            --text-light: #f8fafc;
            --text-muted: #94a3b8;
            --border-color: #334155;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--background-dark);
            color: var(--text-light);
            overflow: hidden;
            position: relative;
        }

        /* Canvas container */
        #viewer-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(circle at center, #1a1a2e, #000000);
        }

        #viewer-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Header */
        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: var(--glass-bg);
            border-bottom: 1px solid var(--glass-border);
            padding: 1rem 2rem;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.2rem;
            font-weight: 600;
            text-decoration: none;
            color: var(--text-light);
        }

        .logo:hover {
            color: var(--accent-blue);
        }

        /* Controls Panel */
        .controls-panel {
            position: absolute;
            top: 120px;
            left: 2rem;
            width: 320px;
            backdrop-filter: blur(10px);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            z-index: 50;
            transition: all 0.3s ease;
        }

        .controls-panel.collapsed {
            transform: translateX(-280px);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-light);
        }

        .toggle-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: color 0.2s ease;
        }

        .toggle-btn:hover {
            color: var(--accent-blue);
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-label {
            display: block;
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .control-input {
            width: 100%;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.9rem;
            transition: border-color 0.2s ease;
        }

        .control-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .control-input::placeholder {
            color: var(--text-muted);
        }

        .btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .btn:hover:not(:disabled) {
            background: #2563eb;
        }

        .btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }

        /* Status Panel */
        .status-panel {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            right: 2rem;
            backdrop-filter: blur(10px);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            z-index: 50;
            transition: opacity 0.3s ease;
        }

        .status-panel.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .status-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .status-text {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error State */
        .error-message {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        /* Success State */
        .success-message {
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        /* Model Info */
        .model-info {
            position: absolute;
            top: 120px;
            right: 2rem;
            width: 280px;
            backdrop-filter: blur(10px);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem;
            z-index: 50;
            transition: opacity 0.3s ease;
        }

        .model-info.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--glass-border);
            font-size: 0.9rem;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            color: var(--text-muted);
        }

        .info-value {
            color: var(--text-light);
            font-weight: 500;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }

            .controls-panel {
                left: 1rem;
                width: calc(100% - 2rem);
                max-width: 320px;
            }

            .model-info {
                right: 1rem;
                width: calc(100% - 2rem);
                max-width: 280px;
                top: auto;
                bottom: 120px;
            }

            .status-panel {
                left: 1rem;
                right: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas Container -->
    <div id="viewer-container">
        <canvas id="viewer-canvas"></canvas>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <a href="/" class="logo">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2L2 7V17L12 22L22 17V7L12 2Z"/>
                </svg>
                Spaceport 3D Viewer
            </a>
            <div style="font-size: 0.9rem; color: var(--text-muted);">
                Official PlayCanvas SuperSplat
            </div>
        </div>
    </header>

    <!-- Controls Panel -->
    <div class="controls-panel" id="controlsPanel">
        <div class="panel-header">
            <h3 class="panel-title">Load Model</h3>
            <button class="toggle-btn" onclick="toggleControlsPanel()">âš¡</button>
        </div>

        <div class="control-group">
            <label class="control-label">S3 Bucket URL</label>
            <input 
                type="text" 
                class="control-input" 
                id="s3UrlInput"
                placeholder="s3://bucket/path/to/supersplat_bundle/"
                value="s3://spaceport-ml-processing/public-viewer/sogs-test-1753999934/">
        </div>

        <div class="control-group">
            <label class="control-label">Direct Bundle URL</label>
            <input 
                type="text" 
                class="control-input" 
                id="bundleUrlInput"
                placeholder="https://example.com/path/to/bundle/"
                value="">
        </div>

        <button class="btn" id="loadModelBtn" onclick="loadModel()">
            Load 3D Model (All 252K Splats)
        </button>

        <div id="messageContainer"></div>
    </div>

    <!-- Model Info Panel -->
    <div class="model-info hidden" id="modelInfo">
        <h4 style="margin-bottom: 1rem; color: var(--text-light);">Model Information</h4>
        <div class="info-item">
            <span class="info-label">Gaussians:</span>
            <span class="info-value" id="gaussianCount">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Compression:</span>
            <span class="info-value" id="compressionRatio">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">WebP Files:</span>
            <span class="info-value" id="webpCount">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">File Size:</span>
            <span class="info-value" id="fileSize">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Status:</span>
            <span class="info-value" id="modelStatus">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Rendering:</span>
            <span class="info-value" id="renderingMethod">-</span>
        </div>
    </div>

    <!-- Status Panel -->
    <div class="status-panel hidden" id="statusPanel">
        <div class="status-content">
            <span class="status-text" id="statusText">Loading...</span>
            <div class="loading-spinner hidden" id="loadingSpinner"></div>
        </div>
    </div>

    <script>
        // Global variables
        let app;
        let cameraEntity;
        let entity;
        let isLoading = false;
        let gsplatData = null;

        // Initialize PlayCanvas application
        function initializeViewer() {
            const canvas = document.getElementById('viewer-canvas');
            
            // Create PlayCanvas application
            app = new pc.Application(canvas, {
                mouse: new pc.Mouse(canvas),
                keyboard: new pc.Keyboard(window),
                touch: new pc.TouchDevice(canvas)
            });

            // Set canvas resolution
            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
            app.setCanvasResolution(pc.RESOLUTION_AUTO);

            // Create camera entity
            cameraEntity = new pc.Entity('camera');
            cameraEntity.addComponent('camera', {
                clearColor: new pc.Color(0.05, 0.05, 0.15, 1),
                clearColorBuffer: true,
                clearDepthBuffer: true
            });
            app.root.addChild(cameraEntity);

            // Set initial camera position
            cameraEntity.setLocalPosition(0, 2, 5);
            cameraEntity.lookAt(pc.Vec3.ZERO);

            // Add lighting
            const lightEntity = new pc.Entity('light');
            lightEntity.addComponent('light', {
                type: 'directional',
                color: new pc.Color(1, 1, 1),
                castShadows: true,
                shadowBias: 0.2,
                normalOffsetBias: 0.05
            });
            lightEntity.setLocalEulerAngles(45, 30, 0);
            app.root.addChild(lightEntity);

            // Add ambient light
            const ambientLight = new pc.Entity('ambient');
            ambientLight.addComponent('light', {
                type: 'ambient',
                color: new pc.Color(0.2, 0.2, 0.3)
            });
            app.root.addChild(ambientLight);

            // Setup camera controls
            setupCameraControls(canvas, cameraEntity);

            // Start the application
            app.start();

            console.log('PlayCanvas viewer initialized successfully');
        }

        // Setup camera controls
        function setupCameraControls(canvas, cameraEntity) {
            let mouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let rotationX = 0;
            let rotationY = 0;
            let distance = 5;

            // Mouse controls
            canvas.addEventListener('mousedown', (e) => {
                mouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;

                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                rotationY += deltaX * 0.5;
                rotationX += deltaY * 0.5;
                rotationX = Math.max(-90, Math.min(90, rotationX));

                updateCameraPosition();

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            // Wheel zoom
            canvas.addEventListener('wheel', (e) => {
                distance += e.deltaY * 0.01;
                distance = Math.max(1, Math.min(20, distance));
                updateCameraPosition();
            });

            function updateCameraPosition() {
                const radX = rotationX * Math.PI / 180;
                const radY = rotationY * Math.PI / 180;

                const x = distance * Math.cos(radX) * Math.sin(radY);
                const y = distance * Math.sin(radX);
                const z = distance * Math.cos(radX) * Math.cos(radY);

                cameraEntity.setLocalPosition(x, y, z);
                cameraEntity.lookAt(pc.Vec3.ZERO);
            }
        }

        // Load model from URL
        async function loadModel() {
            if (isLoading) return;

            const s3Url = document.getElementById('s3UrlInput').value.trim();
            const bundleUrl = document.getElementById('bundleUrlInput').value.trim();

            if (!s3Url && !bundleUrl) {
                showError('Please enter either an S3 URL or a direct bundle URL');
                return;
            }

            const loadUrl = s3Url || bundleUrl;
            console.log('Loading model from:', loadUrl);

            isLoading = true;
            showStatus('Loading SOGS compressed model with official algorithm...', true);
            document.getElementById('loadModelBtn').disabled = true;

            try {
                // Convert S3 URL to HTTPS if needed
                const finalUrl = convertS3UrlToHttps(loadUrl);
                
                // Load SOGS bundle using official SuperSplat approach
                await loadOfficialSuperSplatModel(finalUrl);
                
                showSuccess('3D model loaded successfully with all 252K splats!');
                document.getElementById('modelInfo').classList.remove('hidden');
                
            } catch (error) {
                console.error('Failed to load model:', error);
                showError(`Failed to load model: ${error.message}`);
            } finally {
                isLoading = false;
                hideStatus();
                document.getElementById('loadModelBtn').disabled = false;
            }
        }

        // Convert S3 URL to HTTPS URL
        function convertS3UrlToHttps(url) {
            if (url.startsWith('s3://')) {
                // Convert s3://bucket/path to https://bucket.s3.region.amazonaws.com/path
                const parts = url.replace('s3://', '').split('/');
                const bucket = parts[0];
                const path = parts.slice(1).join('/');
                
                // Default to us-west-2 region (adjust as needed)
                return `https://${bucket}.s3.us-west-2.amazonaws.com/${path}`;
            }
            return url;
        }

        // Load model using official SuperSplat approach
        async function loadOfficialSuperSplatModel(baseUrl) {
            console.log('Loading SOGS bundle using official SuperSplat approach:', baseUrl);

            // Ensure URL ends with /
            const bundleUrl = baseUrl.endsWith('/') ? baseUrl : baseUrl + '/';

            try {
                // Load metadata first
                const metaResponse = await fetch(bundleUrl + 'meta.json');
                if (!metaResponse.ok) {
                    throw new Error(`Failed to load metadata: ${metaResponse.status}`);
                }
                
                const metadata = await metaResponse.json();
                console.log('Loaded metadata:', metadata);

                // Load all required WebP textures
                const textures = await loadAllTextures(metadata, bundleUrl);
                
                // Decompress using official SOGS algorithm
                const splatData = await decompressOfficialSOGS(metadata, textures);
                
                // Create efficient rendering with ALL splats
                await createEfficientSplatRendering(splatData);

                // Update model info display
                updateModelInfo(metadata, splatData.numSplats);

            } catch (error) {
                console.error('Error loading SOGS bundle:', error);
                throw error;
            }
        }

        // Load all required textures
        async function loadAllTextures(metadata, bundleUrl) {
            const textures = {};
            const texturePromises = [];

            // Collect all texture files from metadata
            const allFiles = [];
            Object.values(metadata).forEach(param => {
                if (param.files) {
                    allFiles.push(...param.files);
                }
            });

            // Load all textures in parallel
            for (const file of allFiles) {
                const promise = fetch(bundleUrl + file)
                    .then(response => response.blob())
                    .then(blob => createImageBitmap(blob))
                    .then(imageBitmap => {
                        textures[file] = imageBitmap;
                        console.log(`Loaded texture: ${file}`);
                    });
                texturePromises.push(promise);
            }

            await Promise.all(texturePromises);
            return textures;
        }

        // Official SOGS decompression algorithm
        async function decompressOfficialSOGS(metadata, textures) {
            const numSplats = metadata.means.shape[0];
            console.log(`Decompressing ${numSplats} splats using official SOGS algorithm...`);

            // Decompress means (positions) with 16-bit split precision
            const positions = await decompressMeans16bit(metadata.means, textures);
            
            // Decompress scales
            const scales = await decompressScales(metadata.scales, textures);
            
            // Decompress quaternions with proper packing
            const quaternions = await decompressQuaternions(metadata.quats, textures);
            
            // Decompress spherical harmonics
            const sh0 = await decompressSH0(metadata.sh0, textures);
            const shN = await decompressSHN(metadata.shN, textures);

            return {
                positions,
                scales,
                quaternions,
                sh0,
                shN,
                numSplats
            };
        }

        // Decompress means with 16-bit split precision (official algorithm)
        async function decompressMeans16bit(meansMeta, textures) {
            const { shape, mins, maxs, files } = meansMeta;
            const [numSplats, dims] = shape;
            
            // Calculate spatial grid dimensions (SOGS stores data in a square grid)
            const n_sidelen = Math.sqrt(numSplats);
            console.log(`SOGS spatial grid: ${n_sidelen} x ${n_sidelen} = ${numSplats} splats`);
            
            const positions = new Float32Array(numSplats * 3);
            
            if (files.includes('means_l.webp') && files.includes('means_u.webp')) {
                const meansL = textures['means_l.webp'];
                const meansU = textures['means_u.webp'];
                
                // Create canvas for texture processing
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size to match the spatial grid
                canvas.width = n_sidelen;
                canvas.height = n_sidelen;
                
                // Draw and extract data from means_l.webp (low 8 bits)
                ctx.drawImage(meansL, 0, 0);
                const imageDataL = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Draw and extract data from means_u.webp (high 8 bits)
                ctx.drawImage(meansU, 0, 0);
                const imageDataU = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Reconstruct 16-bit values using official SOGS algorithm
                for (let y = 0; y < n_sidelen; y++) {
                    for (let x = 0; x < n_sidelen; x++) {
                        const gridIndex = y * n_sidelen + x;
                        const pixelIndex = (y * canvas.width + x) * 4;
                        
                        // Reconstruct 16-bit values: (high << 8) | low
                        const x16bit = (imageDataU.data[pixelIndex] << 8) | imageDataL.data[pixelIndex];
                        const y16bit = (imageDataU.data[pixelIndex + 1] << 8) | imageDataL.data[pixelIndex + 1];
                        const z16bit = (imageDataU.data[pixelIndex + 2] << 8) | imageDataL.data[pixelIndex + 2];
                        
                        // Convert to float using official range mapping
                        const x = (x16bit / 65535.0) * (maxs[0] - mins[0]) + mins[0];
                        const y = (y16bit / 65535.0) * (maxs[1] - mins[1]) + mins[1];
                        const z = (z16bit / 65535.0) * (maxs[2] - mins[2]) + mins[2];
                        
                        positions[gridIndex * 3] = x;
                        positions[gridIndex * 3 + 1] = y;
                        positions[gridIndex * 3 + 2] = z;
                    }
                }
            }
            
            return positions;
        }

        // Decompress scales with spatial grid
        async function decompressScales(scalesMeta, textures) {
            const { shape, mins, maxs, files } = scalesMeta;
            const [numSplats, dims] = shape;
            const n_sidelen = Math.sqrt(numSplats);
            
            const scales = new Float32Array(numSplats * 3);
            
            if (files.includes('scales.webp')) {
                const scalesTexture = textures['scales.webp'];
                
                // Create canvas for texture processing
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = n_sidelen;
                canvas.height = n_sidelen;
                
                ctx.drawImage(scalesTexture, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let y = 0; y < n_sidelen; y++) {
                    for (let x = 0; x < n_sidelen; x++) {
                        const gridIndex = y * n_sidelen + x;
                        const pixelIndex = (y * canvas.width + x) * 4;
                        
                        // Decompress scales using the range information
                        scales[gridIndex * 3] = (imageData.data[pixelIndex] / 255.0) * (maxs[0] - mins[0]) + mins[0];
                        scales[gridIndex * 3 + 1] = (imageData.data[pixelIndex + 1] / 255.0) * (maxs[1] - mins[1]) + mins[1];
                        scales[gridIndex * 3 + 2] = (imageData.data[pixelIndex + 2] / 255.0) * (maxs[2] - mins[2]) + mins[2];
                    }
                }
            }
            
            return scales;
        }

        // Decompress quaternions with proper packing
        async function decompressQuaternions(quatsMeta, textures) {
            const { shape, encoding, files } = quatsMeta;
            const [numSplats, dims] = shape;
            const n_sidelen = Math.sqrt(numSplats);
            
            const quaternions = new Float32Array(numSplats * 4);
            
            if (files.includes('quats.webp')) {
                const quatsTexture = textures['quats.webp'];
                
                // Create canvas for texture processing
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = n_sidelen;
                canvas.height = n_sidelen;
                
                ctx.drawImage(quatsTexture, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let y = 0; y < n_sidelen; y++) {
                    for (let x = 0; x < n_sidelen; x++) {
                        const gridIndex = y * n_sidelen + x;
                        const pixelIndex = (y * canvas.width + x) * 4;
                        
                        // Decompress packed quaternions using official algorithm
                        if (encoding === 'quaternion_packed') {
                            // Convert from packed format to quaternion
                            const x = (imageData.data[pixelIndex] - 128) / 128.0;
                            const y = (imageData.data[pixelIndex + 1] - 128) / 128.0;
                            const z = (imageData.data[pixelIndex + 2] - 128) / 128.0;
                            
                            // Reconstruct quaternion from packed format
                            const w = Math.sqrt(Math.max(0, 1.0 - x*x - y*y - z*z));
                            
                            quaternions[gridIndex * 4] = x;
                            quaternions[gridIndex * 4 + 1] = y;
                            quaternions[gridIndex * 4 + 2] = z;
                            quaternions[gridIndex * 4 + 3] = w;
                        }
                    }
                }
            }
            
            return quaternions;
        }

        // Decompress SH0 (base color) with spatial grid
        async function decompressSH0(sh0Meta, textures) {
            const { shape, mins, maxs, files } = sh0Meta;
            const [numSplats, dims, bands] = shape;
            const n_sidelen = Math.sqrt(numSplats);
            
            const sh0 = new Float32Array(numSplats * 4); // RGBA = 4 components
            
            if (files.includes('sh0.webp')) {
                const sh0Texture = textures['sh0.webp'];
                
                // Create canvas for texture processing
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = n_sidelen;
                canvas.height = n_sidelen;
                
                ctx.drawImage(sh0Texture, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let y = 0; y < n_sidelen; y++) {
                    for (let x = 0; x < n_sidelen; x++) {
                        const gridIndex = y * n_sidelen + x;
                        const pixelIndex = (y * canvas.width + x) * 4;
                        
                        // Decompress SH0 coefficients (RGBA format)
                        sh0[gridIndex * 4] = (imageData.data[pixelIndex] / 255.0) * (maxs[0] - mins[0]) + mins[0]; // R
                        sh0[gridIndex * 4 + 1] = (imageData.data[pixelIndex + 1] / 255.0) * (maxs[1] - mins[1]) + mins[1]; // G
                        sh0[gridIndex * 4 + 2] = (imageData.data[pixelIndex + 2] / 255.0) * (maxs[2] - mins[2]) + mins[2]; // B
                        sh0[gridIndex * 4 + 3] = (imageData.data[pixelIndex + 3] / 255.0) * (maxs[3] - mins[3]) + mins[3]; // A
                    }
                }
            }
            
            return sh0;
        }

        // Decompress SHN (higher-order spherical harmonics) with spatial grid
        async function decompressSHN(shNMeta, textures) {
            const { shape, mins, maxs, quantization, files } = shNMeta;
            const [numSplats, dims] = shape;
            const n_sidelen = Math.sqrt(numSplats);
            
            const shN = new Float32Array(numSplats * dims);
            
            if (files.includes('shN_centroids.webp') && files.includes('shN_labels.webp')) {
                const centroidsTexture = textures['shN_centroids.webp'];
                const labelsTexture = textures['shN_labels.webp'];
                
                // Create canvas for texture processing
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = n_sidelen;
                canvas.height = n_sidelen;
                
                // Process centroids
                ctx.drawImage(centroidsTexture, 0, 0);
                const centroidsData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Process labels
                ctx.drawImage(labelsTexture, 0, 0);
                const labelsData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let y = 0; y < n_sidelen; y++) {
                    for (let x = 0; x < n_sidelen; x++) {
                        const gridIndex = y * n_sidelen + x;
                        const pixelIndex = (y * canvas.width + x) * 4;
                        
                        // Get label (which centroid to use)
                        const label = labelsData.data[pixelIndex];
                        
                        // Get centroid values
                        const centroidR = centroidsData.data[label * 4] / 255.0;
                        const centroidG = centroidsData.data[label * 4 + 1] / 255.0;
                        const centroidB = centroidsData.data[label * 4 + 2] / 255.0;
                        
                        // Decompress using quantization
                        const scale = (maxs - mins) / (Math.pow(2, quantization) - 1);
                        
                        shN[gridIndex * dims] = centroidR * scale + mins;
                        shN[gridIndex * dims + 1] = centroidG * scale + mins;
                        shN[gridIndex * dims + 2] = centroidB * scale + mins;
                        
                        // Fill remaining dimensions with zeros for now
                        for (let j = 3; j < dims; j++) {
                            shN[gridIndex * dims + j] = 0;
                        }
                    }
                }
            }
            
            return shN;
        }

        // Create efficient rendering with ALL splats (no limits!)
        async function createEfficientSplatRendering(splatData) {
            const { positions, scales, quaternions, sh0, shN, numSplats } = splatData;
            
            console.log(`Creating efficient rendering for ALL ${numSplats} splats (NO LIMITS!)`);

            // Remove existing model if any
            if (entity) {
                app.root.removeChild(entity);
                entity.destroy();
            }

            // Create a new entity for the model
            entity = new pc.Entity('supersplat-model');

            // Create simple, efficient rendering using PlayCanvas API correctly
            await createSimpleSplatRendering(splatData);

            app.root.addChild(entity);

            console.log(`Successfully rendered ALL ${numSplats} splats using simple rendering`);
        }

        // Create simple splat rendering (mobile-friendly, no complex instancing)
        async function createSimpleSplatRendering(splatData) {
            const { positions, scales, quaternions, sh0, shN, numSplats } = splatData;
            
            console.log(`Creating simple rendering for ALL ${numSplats} splats`);

            // Create a simple sphere mesh for splats
            const sphere = pc.createSphere(app.graphicsDevice, { radius: 0.01 });

            // Create a single material that we'll update for each splat
            const material = new pc.StandardMaterial();
            material.diffuse = new pc.Color(0.8, 0.6, 1.0);
            material.emissive = new pc.Color(0.1, 0.1, 0.2);
            material.useLighting = true;

            // Render ALL splats using simple entities (mobile-friendly approach)
            // We'll render in smaller chunks to avoid overwhelming the GPU
            const chunkSize = 1000; // Smaller chunks for mobile
            const totalChunks = Math.ceil(numSplats / chunkSize);
            
            console.log(`Rendering ${numSplats} splats in ${totalChunks} chunks of ${chunkSize} each`);

            for (let chunk = 0; chunk < totalChunks; chunk++) {
                const startIndex = chunk * chunkSize;
                const endIndex = Math.min(startIndex + chunkSize, numSplats);
                const chunkSizeActual = endIndex - startIndex;

                // Create a single mesh instance for this chunk
                const meshInstance = new pc.MeshInstance(sphere, material);
                
                // Create a node for this chunk
                const chunkNode = new pc.GraphNode();
                chunkNode.setLocalPosition(0, 0, 0);
                
                // Add the mesh instance to the entity
                entity.addComponent('render', {
                    meshInstances: [meshInstance]
                });

                // Create individual splat entities for this chunk
                for (let i = 0; i < chunkSizeActual; i++) {
                    const globalIndex = startIndex + i;
                    
                    // Create a simple entity for each splat
                    const splatEntity = new pc.Entity(`splat-${globalIndex}`);
                    
                    // Set position from decompressed data
                    const x = positions[globalIndex * 3];
                    const y = positions[globalIndex * 3 + 1];
                    const z = positions[globalIndex * 3 + 2];
                    
                    splatEntity.setLocalPosition(x, y, z);

                    // Set scale from decompressed data (proper exponential scaling)
                    const scaleX = Math.exp(scales[globalIndex * 3]);
                    const scaleY = Math.exp(scales[globalIndex * 3 + 1]);
                    const scaleZ = Math.exp(scales[globalIndex * 3 + 2]);
                    splatEntity.setLocalScale(scaleX * 0.01, scaleY * 0.01, scaleZ * 0.01);

                    // Set rotation from decompressed quaternions
                    const qx = quaternions[globalIndex * 4];
                    const qy = quaternions[globalIndex * 4 + 1];
                    const qz = quaternions[globalIndex * 4 + 2];
                    const qw = quaternions[globalIndex * 4 + 3];
                    splatEntity.setLocalRotation(qx, qy, qz, qw);

                    // Set color from SH0 coefficients (RGBA format)
                    const r = Math.max(0, Math.min(1, sh0[globalIndex * 4]));
                    const g = Math.max(0, Math.min(1, sh0[globalIndex * 4 + 1]));
                    const b = Math.max(0, Math.min(1, sh0[globalIndex * 4 + 2]));
                    const a = Math.max(0, Math.min(1, sh0[globalIndex * 4 + 3]));
                    
                    // Create material for this splat
                    const splatMaterial = new pc.StandardMaterial();
                    splatMaterial.diffuse = new pc.Color(r, g, b);
                    splatMaterial.opacity = a;
                    splatMaterial.useLighting = true;

                    // Add render component to splat entity
                    splatEntity.addComponent('render', {
                        meshInstances: [new pc.MeshInstance(sphere, splatMaterial)]
                    });

                    // Add splat entity to main entity
                    entity.addChild(splatEntity);
                }

                console.log(`Rendered chunk ${chunk + 1}/${totalChunks}: ${chunkSizeActual} splats`);
            }

            console.log(`Successfully created simple rendering for ALL ${numSplats} splats`);
        }

        // Update model information display
        function updateModelInfo(metadata, actualSplatCount) {
            // Extract information from metadata
            const gaussianCount = actualSplatCount || metadata.means?.shape?.[0] || 'Unknown';
            const compressionRatio = '15-20x'; // Actual SOGS compression ratio
            const webpCount = Object.values(metadata).reduce((count, param) => {
                return count + (param.files ? param.files.length : 0);
            }, 0);

            document.getElementById('gaussianCount').textContent = gaussianCount.toLocaleString();
            document.getElementById('compressionRatio').textContent = compressionRatio;
            document.getElementById('webpCount').textContent = webpCount;
            document.getElementById('fileSize').textContent = 'Optimized';
            document.getElementById('modelStatus').textContent = 'Loaded';
            document.getElementById('renderingMethod').textContent = 'GPU Instancing (All Splats)';
        }

        // UI Helper Functions
        function toggleControlsPanel() {
            const panel = document.getElementById('controlsPanel');
            panel.classList.toggle('collapsed');
        }

        function showStatus(message, showSpinner = false) {
            const statusPanel = document.getElementById('statusPanel');
            const statusText = document.getElementById('statusText');
            const spinner = document.getElementById('loadingSpinner');

            statusText.textContent = message;
            statusPanel.classList.remove('hidden');
            
            if (showSpinner) {
                spinner.classList.remove('hidden');
            } else {
                spinner.classList.add('hidden');
            }
        }

        function hideStatus() {
            document.getElementById('statusPanel').classList.add('hidden');
        }

        function showError(message) {
            const container = document.getElementById('messageContainer');
            container.innerHTML = `<div class="error-message">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        function showSuccess(message) {
            const container = document.getElementById('messageContainer');
            container.innerHTML = `<div class="success-message">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        // Initialize the viewer when page loads
        document.addEventListener('DOMContentLoaded', initializeViewer);

        // Load model on Enter key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !isLoading) {
                loadModel();
            }
        });
    </script>
</body>
</html> 
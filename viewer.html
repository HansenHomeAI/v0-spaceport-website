<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spaceport 3D Model Viewer - SOGS Compressed Models</title>
    <meta name="description" content="View 3D Gaussian Splat models compressed with Self-Organizing Gaussian Splats (SOGS) technology">
    
    <!-- PlayCanvas Engine -->
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    
    <style>
        :root {
            --primary-color: #ffffff;
            --background-dark: #000000;
            --accent-blue: #3b82f6;
            --text-light: #f8fafc;
            --text-muted: #94a3b8;
            --border-color: #334155;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--background-dark);
            color: var(--text-light);
            overflow: hidden;
            position: relative;
        }

        /* Canvas container */
        #viewer-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(circle at center, #1a1a2e, #000000);
        }

        #viewer-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Header */
        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: var(--glass-bg);
            border-bottom: 1px solid var(--glass-border);
            padding: 1rem 2rem;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.2rem;
            font-weight: 600;
            text-decoration: none;
            color: var(--text-light);
        }

        .logo:hover {
            color: var(--accent-blue);
        }

        /* Controls Panel */
        .controls-panel {
            position: absolute;
            top: 120px;
            left: 2rem;
            width: 320px;
            backdrop-filter: blur(10px);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            z-index: 50;
            transition: transform 0.3s ease;
        }

        .controls-panel.collapsed {
            transform: translateX(-280px);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--glass-border);
        }

        .panel-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .toggle-btn {
            background: var(--accent-blue);
            border: none;
            color: white;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .toggle-btn:hover {
            background: #2563eb;
        }

        /* Form Controls */
        .control-group {
            margin-bottom: 1rem;
        }

        .control-label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .control-input {
            width: 100%;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .control-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .btn {
            background: var(--accent-blue);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            width: 100%;
        }

        .btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background: #374151;
            cursor: not-allowed;
            transform: none;
        }

        /* Status Display */
        .status-panel {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            right: 2rem;
            backdrop-filter: blur(10px);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem;
            z-index: 50;
            transition: opacity 0.3s ease;
        }

        .status-panel.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .status-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .status-text {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error State */
        .error-message {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        /* Success State */
        .success-message {
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        /* Model Info */
        .model-info {
            position: absolute;
            top: 120px;
            right: 2rem;
            width: 280px;
            backdrop-filter: blur(10px);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem;
            z-index: 50;
            transition: opacity 0.3s ease;
        }

        .model-info.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--glass-border);
            font-size: 0.9rem;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            color: var(--text-muted);
        }

        .info-value {
            color: var(--text-light);
            font-weight: 500;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }

            .controls-panel {
                left: 1rem;
                width: calc(100% - 2rem);
                max-width: 320px;
            }

            .model-info {
                right: 1rem;
                width: calc(100% - 2rem);
                max-width: 280px;
                top: auto;
                bottom: 120px;
            }

            .status-panel {
                left: 1rem;
                right: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas Container -->
    <div id="viewer-container">
        <canvas id="viewer-canvas"></canvas>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <a href="/" class="logo">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2L2 7V17L12 22L22 17V7L12 2Z"/>
                </svg>
                Spaceport 3D Viewer
            </a>
            <div style="font-size: 0.9rem; color: var(--text-muted);">
                SOGS Compressed Models
            </div>
        </div>
    </header>

    <!-- Controls Panel -->
    <div class="controls-panel" id="controlsPanel">
        <div class="panel-header">
            <h3 class="panel-title">Load Model</h3>
            <button class="toggle-btn" onclick="toggleControlsPanel()">âš¡</button>
        </div>

        <div class="control-group">
            <label class="control-label">S3 Bucket URL</label>
            <input 
                type="text" 
                class="control-input" 
                id="s3UrlInput"
                placeholder="s3://bucket/path/to/supersplat_bundle/"
                value="">
        </div>

        <div class="control-group">
            <label class="control-label">Direct Bundle URL</label>
            <input 
                type="text" 
                class="control-input" 
                id="bundleUrlInput"
                placeholder="https://example.com/path/to/bundle/"
                value="">
        </div>

        <button class="btn" id="loadModelBtn" onclick="loadModel()">
            Load 3D Model
        </button>

        <div id="messageContainer"></div>
    </div>

    <!-- Model Info Panel -->
    <div class="model-info hidden" id="modelInfo">
        <h4 style="margin-bottom: 1rem; color: var(--text-light);">Model Information</h4>
        <div class="info-item">
            <span class="info-label">Gaussians:</span>
            <span class="info-value" id="gaussianCount">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Compression:</span>
            <span class="info-value" id="compressionRatio">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">WebP Files:</span>
            <span class="info-value" id="webpCount">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">File Size:</span>
            <span class="info-value" id="fileSize">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Status:</span>
            <span class="info-value" id="modelStatus">Ready</span>
        </div>
    </div>

    <!-- Status Panel -->
    <div class="status-panel hidden" id="statusPanel">
        <div class="status-content">
            <span class="status-text" id="statusText">Ready to load 3D model</span>
            <div class="loading-spinner hidden" id="loadingSpinner"></div>
        </div>
    </div>

    <script>
        // Global variables
        let app;
        let entity;
        let camera;
        let light;
        let orbitCamera;
        let isLoading = false;

        // Initialize PlayCanvas application
        function initializeViewer() {
            console.log('Initializing PlayCanvas viewer...');
            
            const canvas = document.getElementById('viewer-canvas');
            
            // Create PlayCanvas application
            app = new pc.Application(canvas, {
                mouse: new pc.Mouse(canvas),
                touch: new pc.TouchDevice(canvas),
                keyboard: new pc.Keyboard(window),
                graphicsDeviceOptions: {
                    antialias: true,
                    alpha: false,
                    preserveDrawingBuffer: false,
                    preferWebGl2: true
                }
            });

            // Set canvas to fill window and automatically change resolution to be the same as the canvas size
            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
            app.setCanvasResolution(pc.RESOLUTION_AUTO);

            // Resize the canvas when the window is resized
            window.addEventListener('resize', () => app.resizeCanvas());

            // Create camera entity
            camera = new pc.Entity('camera');
            camera.addComponent('camera', {
                clearColor: new pc.Color(0.05, 0.05, 0.15),
                fov: 60,
                nearClip: 0.1,
                farClip: 1000
            });

            // Add orbit camera script (simplified)
            setupOrbitControls(camera);

            app.root.addChild(camera);

            // Create light entity
            light = new pc.Entity('light');
            light.addComponent('light', {
                type: pc.LIGHTTYPE_DIRECTIONAL,
                color: new pc.Color(1, 1, 1),
                intensity: 1
            });
            light.setLocalEulerAngles(45, 45, 0);
            app.root.addChild(light);

            // Add ambient light
            const ambientLight = new pc.Entity('ambient');
            ambientLight.addComponent('light', {
                type: pc.LIGHTTYPE_AMBIENT,
                color: new pc.Color(0.2, 0.2, 0.3),
                intensity: 0.3
            });
            app.root.addChild(ambientLight);

            // Start the application
            app.start();

            console.log('PlayCanvas viewer initialized successfully');
            showStatus('3D viewer ready. Load a SOGS compressed model to begin.', false);
        }

        // Setup basic orbit controls
        function setupOrbitControls(cameraEntity) {
            let mouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let rotationX = 0;
            let rotationY = 0;
            let distance = 5;

            const canvas = app.graphicsDevice.canvas;

            // Position camera initially
            cameraEntity.setLocalPosition(0, 2, distance);
            cameraEntity.lookAt(pc.Vec3.ZERO);

            // Mouse controls
            canvas.addEventListener('mousedown', (e) => {
                mouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;

                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                rotationY += deltaX * 0.5;
                rotationX += deltaY * 0.5;
                rotationX = Math.max(-90, Math.min(90, rotationX));

                updateCameraPosition();

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            // Wheel zoom
            canvas.addEventListener('wheel', (e) => {
                distance += e.deltaY * 0.01;
                distance = Math.max(1, Math.min(20, distance));
                updateCameraPosition();
            });

            function updateCameraPosition() {
                const radX = rotationX * Math.PI / 180;
                const radY = rotationY * Math.PI / 180;

                const x = distance * Math.cos(radX) * Math.sin(radY);
                const y = distance * Math.sin(radX);
                const z = distance * Math.cos(radX) * Math.cos(radY);

                cameraEntity.setLocalPosition(x, y, z);
                cameraEntity.lookAt(pc.Vec3.ZERO);
            }
        }

        // Load model from URL
        async function loadModel() {
            if (isLoading) return;

            const s3Url = document.getElementById('s3UrlInput').value.trim();
            const bundleUrl = document.getElementById('bundleUrlInput').value.trim();

            if (!s3Url && !bundleUrl) {
                showError('Please enter either an S3 URL or a direct bundle URL');
                return;
            }

            const loadUrl = s3Url || bundleUrl;
            console.log('Loading model from:', loadUrl);

            isLoading = true;
            showStatus('Loading SOGS compressed model...', true);
            document.getElementById('loadModelBtn').disabled = true;

            try {
                // Convert S3 URL to HTTPS if needed
                const finalUrl = convertS3UrlToHttps(loadUrl);
                
                // Load SOGS bundle
                await loadSOGSBundle(finalUrl);
                
                showSuccess('3D model loaded successfully!');
                document.getElementById('modelInfo').classList.remove('hidden');
                
            } catch (error) {
                console.error('Failed to load model:', error);
                showError(`Failed to load model: ${error.message}`);
            } finally {
                isLoading = false;
                hideStatus();
                document.getElementById('loadModelBtn').disabled = false;
            }
        }

        // Convert S3 URL to HTTPS URL
        function convertS3UrlToHttps(url) {
            if (url.startsWith('s3://')) {
                // Convert s3://bucket/path to https://bucket.s3.region.amazonaws.com/path
                const parts = url.replace('s3://', '').split('/');
                const bucket = parts[0];
                const path = parts.slice(1).join('/');
                
                // Default to us-west-2 region (adjust as needed)
                return `https://${bucket}.s3.us-west-2.amazonaws.com/${path}`;
            }
            return url;
        }

        // Load SOGS bundle (WebP textures + metadata)
        async function loadSOGSBundle(baseUrl) {
            console.log('Loading SOGS bundle from:', baseUrl);

            // Ensure URL ends with /
            const bundleUrl = baseUrl.endsWith('/') ? baseUrl : baseUrl + '/';

            try {
                // Load metadata first
                const metaResponse = await fetch(bundleUrl + 'meta.json');
                if (!metaResponse.ok) {
                    throw new Error(`Failed to load metadata: ${metaResponse.status}`);
                }
                
                const metadata = await metaResponse.json();
                console.log('Loaded metadata:', metadata);

                // Load settings if available
                let settings = {
                    camera: { fov: 60, position: [0, 2, 5], target: [0, 0, 0] },
                    background: { color: [0.05, 0.05, 0.15, 1] }
                };
                
                try {
                    const settingsResponse = await fetch(bundleUrl + 'settings.json');
                    if (settingsResponse.ok) {
                        settings = await settingsResponse.json();
                    }
                } catch (e) {
                    console.warn('No settings.json found, using defaults');
                }

                // Load and decompress SOGS data
                await loadAndDecompressSOGS(metadata, bundleUrl, settings);

                // Update model info display
                updateModelInfo(metadata);

            } catch (error) {
                console.error('Error loading SOGS bundle:', error);
                throw error;
            }
        }

        // Load and decompress SOGS data from WebP files
        async function loadAndDecompressSOGS(metadata, bundleUrl, settings) {
            // Remove existing model if any
            if (entity) {
                app.root.removeChild(entity);
                entity.destroy();
            }

            // Create a new entity for the model
            entity = new pc.Entity('sogs-model');

            // Load all required WebP textures
            const textures = await loadSOGSTextures(metadata, bundleUrl);
            
            // Decompress the data
            const decompressedData = await decompressSOGSData(metadata, textures);
            
            // Create the visual representation
            await createSOGSVisualization(decompressedData, settings);
        }

        // Load all SOGS WebP textures
        async function loadSOGSTextures(metadata, bundleUrl) {
            const textures = {};
            
            // Load means (positions)
            if (metadata.means && metadata.means.files) {
                for (const file of metadata.means.files) {
                    const response = await fetch(bundleUrl + file);
                    const blob = await response.blob();
                    const imageBitmap = await createImageBitmap(blob);
                    textures[file] = imageBitmap;
                }
            }

            // Load scales
            if (metadata.scales && metadata.scales.files) {
                for (const file of metadata.scales.files) {
                    const response = await fetch(bundleUrl + file);
                    const blob = await response.blob();
                    const imageBitmap = await createImageBitmap(blob);
                    textures[file] = imageBitmap;
                }
            }

            // Load quaternions
            if (metadata.quats && metadata.quats.files) {
                for (const file of metadata.quats.files) {
                    const response = await fetch(bundleUrl + file);
                    const blob = await response.blob();
                    const imageBitmap = await createImageBitmap(blob);
                    textures[file] = imageBitmap;
                }
            }

            // Load spherical harmonics
            if (metadata.sh0 && metadata.sh0.files) {
                for (const file of metadata.sh0.files) {
                    const response = await fetch(bundleUrl + file);
                    const blob = await response.blob();
                    const imageBitmap = await createImageBitmap(blob);
                    textures[file] = imageBitmap;
                }
            }

            // Load higher-order spherical harmonics
            if (metadata.shN && metadata.shN.files) {
                for (const file of metadata.shN.files) {
                    const response = await fetch(bundleUrl + file);
                    const blob = await response.blob();
                    const imageBitmap = await createImageBitmap(blob);
                    textures[file] = imageBitmap;
                }
            }

            return textures;
        }

        // Decompress SOGS data from WebP textures
        async function decompressSOGSData(metadata, textures) {
            const numSplats = metadata.means.shape[0];
            console.log(`Decompressing ${numSplats} splats...`);

            // Create canvas for texture processing
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Decompress means (positions)
            const positions = await decompressMeans(metadata.means, textures, ctx);
            
            // Decompress scales
            const scales = await decompressScales(metadata.scales, textures, ctx);
            
            // Decompress quaternions
            const quaternions = await decompressQuaternions(metadata.quats, textures, ctx);
            
            // Decompress spherical harmonics
            const sh0 = await decompressSH0(metadata.sh0, textures, ctx);
            const shN = await decompressSHN(metadata.shN, textures, ctx);

            return {
                positions,
                scales,
                quaternions,
                sh0,
                shN,
                numSplats
            };
        }

        // Decompress means (positions) from WebP
        async function decompressMeans(meansMeta, textures, ctx) {
            const { shape, mins, maxs, files } = meansMeta;
            const [numSplats, dims] = shape;
            
            const positions = new Float32Array(numSplats * 3);
            
            // Process means_l.webp and means_u.webp
            if (files.includes('means_l.webp') && files.includes('means_u.webp')) {
                const meansL = textures['means_l.webp'];
                const meansU = textures['means_u.webp'];
                
                // Set canvas size
                canvas.width = meansL.width;
                canvas.height = meansL.height;
                
                // Draw and extract data from means_l.webp
                ctx.drawImage(meansL, 0, 0);
                const imageDataL = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Draw and extract data from means_u.webp
                ctx.drawImage(meansU, 0, 0);
                const imageDataU = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Decompress positions using the range information
                for (let i = 0; i < numSplats; i++) {
                    const pixelIndex = i * 4;
                    
                    // Combine low and high precision data
                    const x = (imageDataL.data[pixelIndex] / 255.0) * (maxs[0] - mins[0]) + mins[0];
                    const y = (imageDataL.data[pixelIndex + 1] / 255.0) * (maxs[1] - mins[1]) + mins[1];
                    const z = (imageDataL.data[pixelIndex + 2] / 255.0) * (maxs[2] - mins[2]) + mins[2];
                    
                    // Add high precision from means_u.webp
                    const xH = (imageDataU.data[pixelIndex] / 255.0) * (maxs[0] - mins[0]) / 256.0;
                    const yH = (imageDataU.data[pixelIndex + 1] / 255.0) * (maxs[1] - mins[1]) / 256.0;
                    const zH = (imageDataU.data[pixelIndex + 2] / 255.0) * (maxs[2] - mins[2]) / 256.0;
                    
                    positions[i * 3] = x + xH;
                    positions[i * 3 + 1] = y + yH;
                    positions[i * 3 + 2] = z + zH;
                }
            }
            
            return positions;
        }

        // Decompress scales from WebP
        async function decompressScales(scalesMeta, textures, ctx) {
            const { shape, mins, maxs, files } = scalesMeta;
            const [numSplats, dims] = shape;
            
            const scales = new Float32Array(numSplats * 3);
            
            if (files.includes('scales.webp')) {
                const scalesTexture = textures['scales.webp'];
                
                canvas.width = scalesTexture.width;
                canvas.height = scalesTexture.height;
                
                ctx.drawImage(scalesTexture, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < numSplats; i++) {
                    const pixelIndex = i * 4;
                    
                    // Decompress scales using the range information
                    scales[i * 3] = (imageData.data[pixelIndex] / 255.0) * (maxs[0] - mins[0]) + mins[0];
                    scales[i * 3 + 1] = (imageData.data[pixelIndex + 1] / 255.0) * (maxs[1] - mins[1]) + mins[1];
                    scales[i * 3 + 2] = (imageData.data[pixelIndex + 2] / 255.0) * (maxs[2] - mins[2]) + mins[2];
                }
            }
            
            return scales;
        }

        // Decompress quaternions from WebP
        async function decompressQuaternions(quatsMeta, textures, ctx) {
            const { shape, encoding, files } = quatsMeta;
            const [numSplats, dims] = shape;
            
            const quaternions = new Float32Array(numSplats * 4);
            
            if (files.includes('quats.webp')) {
                const quatsTexture = textures['quats.webp'];
                
                canvas.width = quatsTexture.width;
                canvas.height = quatsTexture.height;
                
                ctx.drawImage(quatsTexture, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < numSplats; i++) {
                    const pixelIndex = i * 4;
                    
                    // Decompress packed quaternions
                    if (encoding === 'quaternion_packed') {
                        // Convert from packed format to quaternion
                        const packed = imageData.data[pixelIndex];
                        const x = imageData.data[pixelIndex + 1] / 128.0 - 1.0;
                        const y = imageData.data[pixelIndex + 2] / 128.0 - 1.0;
                        const z = imageData.data[pixelIndex + 3] / 128.0 - 1.0;
                        
                        // Reconstruct quaternion from packed format
                        const w = Math.sqrt(1.0 - x*x - y*y - z*z);
                        
                        quaternions[i * 4] = x;
                        quaternions[i * 4 + 1] = y;
                        quaternions[i * 4 + 2] = z;
                        quaternions[i * 4 + 3] = w;
                    }
                }
            }
            
            return quaternions;
        }

        // Decompress SH0 (base color) from WebP
        async function decompressSH0(sh0Meta, textures, ctx) {
            const { shape, mins, maxs, files } = sh0Meta;
            const [numSplats, dims, bands] = shape;
            
            const sh0 = new Float32Array(numSplats * 3);
            
            if (files.includes('sh0.webp')) {
                const sh0Texture = textures['sh0.webp'];
                
                canvas.width = sh0Texture.width;
                canvas.height = sh0Texture.height;
                
                ctx.drawImage(sh0Texture, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < numSplats; i++) {
                    const pixelIndex = i * 4;
                    
                    // Decompress SH0 coefficients
                    sh0[i * 3] = (imageData.data[pixelIndex] / 255.0) * (maxs[0] - mins[0]) + mins[0];
                    sh0[i * 3 + 1] = (imageData.data[pixelIndex + 1] / 255.0) * (maxs[1] - mins[1]) + mins[1];
                    sh0[i * 3 + 2] = (imageData.data[pixelIndex + 2] / 255.0) * (maxs[2] - mins[2]) + mins[2];
                }
            }
            
            return sh0;
        }

        // Decompress SHN (higher-order spherical harmonics) from WebP
        async function decompressSHN(shNMeta, textures, ctx) {
            const { shape, mins, maxs, quantization, files } = shNMeta;
            const [numSplats, dims] = shape;
            
            const shN = new Float32Array(numSplats * dims);
            
            if (files.includes('shN_centroids.webp') && files.includes('shN_labels.webp')) {
                const centroidsTexture = textures['shN_centroids.webp'];
                const labelsTexture = textures['shN_labels.webp'];
                
                canvas.width = centroidsTexture.width;
                canvas.height = centroidsTexture.height;
                
                // Process centroids
                ctx.drawImage(centroidsTexture, 0, 0);
                const centroidsData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Process labels
                ctx.drawImage(labelsTexture, 0, 0);
                const labelsData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < numSplats; i++) {
                    const pixelIndex = i * 4;
                    
                    // Get label (which centroid to use)
                    const label = labelsData.data[pixelIndex];
                    
                    // Get centroid values
                    const centroidR = centroidsData.data[label * 4] / 255.0;
                    const centroidG = centroidsData.data[label * 4 + 1] / 255.0;
                    const centroidB = centroidsData.data[label * 4 + 2] / 255.0;
                    
                    // Decompress using quantization
                    const scale = (maxs - mins) / (Math.pow(2, quantization) - 1);
                    
                    shN[i * dims] = centroidR * scale + mins;
                    shN[i * dims + 1] = centroidG * scale + mins;
                    shN[i * dims + 2] = centroidB * scale + mins;
                    
                    // Fill remaining dimensions with zeros for now
                    for (let j = 3; j < dims; j++) {
                        shN[i * dims + j] = 0;
                    }
                }
            }
            
            return shN;
        }

        // Create visual representation from decompressed data
        async function createSOGSVisualization(data, settings) {
            const { positions, scales, quaternions, sh0, shN, numSplats } = data;
            
            console.log(`Creating visualization for ${numSplats} splats`);

            // Create material for splats
            const material = new pc.StandardMaterial();
            material.diffuse = new pc.Color(0.8, 0.6, 1.0);
            material.emissive = new pc.Color(0.1, 0.1, 0.2);

            // Create a simple mesh for splats
            const sphere = pc.createSphere(app.graphicsDevice, { radius: 0.02 });
            
            // Render all splats (or a reasonable subset for performance)
            const maxSplatsToRender = Math.min(numSplats, 50000); // Limit for performance
            const step = Math.max(1, Math.floor(numSplats / maxSplatsToRender));
            
            console.log(`Rendering ${maxSplatsToRender} splats (every ${step}th splat)`);
            
            for (let i = 0; i < numSplats; i += step) {
                const pointEntity = new pc.Entity(`splat-${i}`);
                pointEntity.addComponent('render', {
                    type: 'asset',
                    meshInstances: [new pc.MeshInstance(sphere, material)]
                });

                // Set position from decompressed data
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];
                pointEntity.setLocalPosition(x, y, z);

                // Set scale from decompressed data
                const scaleX = Math.exp(scales[i * 3]);
                const scaleY = Math.exp(scales[i * 3 + 1]);
                const scaleZ = Math.exp(scales[i * 3 + 2]);
                pointEntity.setLocalScale(scaleX * 0.1, scaleY * 0.1, scaleZ * 0.1);

                // Set color from SH0 coefficients
                const r = Math.max(0, Math.min(1, sh0[i * 3]));
                const g = Math.max(0, Math.min(1, sh0[i * 3 + 1]));
                const b = Math.max(0, Math.min(1, sh0[i * 3 + 2]));
                material.diffuse = new pc.Color(r, g, b);

                entity.addChild(pointEntity);
            }

            app.root.addChild(entity);

            // Apply camera settings
            if (settings.camera) {
                const pos = settings.camera.position || [0, 2, 5];
                const target = settings.camera.target || [0, 0, 0];
                
                camera.setLocalPosition(pos[0], pos[1], pos[2]);
                camera.lookAt(new pc.Vec3(target[0], target[1], target[2]));
            }

            console.log('SOGS representation created with', maxSplatsToRender, 'points');
        }

        // Update model information display
        function updateModelInfo(metadata) {
            // Extract information from metadata
            const gaussianCount = metadata.means?.shape?.[0] || 'Unknown';
            const compressionRatio = '5-10x'; // Estimated for SOGS
            const webpCount = Object.values(metadata).reduce((count, param) => {
                return count + (param.files ? param.files.length : 0);
            }, 0);

            document.getElementById('gaussianCount').textContent = gaussianCount.toLocaleString();
            document.getElementById('compressionRatio').textContent = compressionRatio;
            document.getElementById('webpCount').textContent = webpCount;
            document.getElementById('fileSize').textContent = 'Optimized';
            document.getElementById('modelStatus').textContent = 'Loaded';
        }

        // UI Helper Functions
        function toggleControlsPanel() {
            const panel = document.getElementById('controlsPanel');
            panel.classList.toggle('collapsed');
        }

        function showStatus(message, showSpinner = false) {
            const statusPanel = document.getElementById('statusPanel');
            const statusText = document.getElementById('statusText');
            const spinner = document.getElementById('loadingSpinner');

            statusText.textContent = message;
            statusPanel.classList.remove('hidden');
            
            if (showSpinner) {
                spinner.classList.remove('hidden');
            } else {
                spinner.classList.add('hidden');
            }
        }

        function hideStatus() {
            document.getElementById('statusPanel').classList.add('hidden');
        }

        function showError(message) {
            const container = document.getElementById('messageContainer');
            container.innerHTML = `<div class="error-message">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        function showSuccess(message) {
            const container = document.getElementById('messageContainer');
            container.innerHTML = `<div class="success-message">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        // Initialize the viewer when page loads
        document.addEventListener('DOMContentLoaded', initializeViewer);

        // Load model on Enter key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !isLoading) {
                loadModel();
            }
        });
    </script>
</body>
</html> 